/**
 * OrionHealth Support Bot - Edge Function
 *
 * This edge function handles Telegram webhooks and creates GitHub issues
 * for user feedback, bug reports, and feature requests.
 *
 * Deploy to: Vercel Edge Functions, Supabase Functions, or Cloudflare Workers
 */

// Types
interface TelegramUpdate {
  update_id: number;
  message?: TelegramMessage;
}

interface TelegramMessage {
  message_id: number;
  from: {
    id: number;
    username?: string;
    first_name: string;
    last_name?: string;
  };
  chat: {
    id: number;
    type: string;
  };
  date: number;
  text?: string;
}

interface TicketType {
  label: string;
  emoji: string;
  githubLabel: string;
}

// Configuration - Set these as environment variables
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || '';
const GITHUB_TOKEN = process.env.GITHUB_TOKEN || '';
const GITHUB_OWNER = 'iberi22';
const GITHUB_REPO = 'local-llm.OrionHealth';

// Ticket classification
const TICKET_TYPES: Record<string, TicketType> = {
  bug: {
    label: 'Bug Report',
    emoji: 'üêõ',
    githubLabel: 'bug'
  },
  feature: {
    label: 'Feature Request',
    emoji: '‚ú®',
    githubLabel: 'enhancement'
  },
  feedback: {
    label: 'Feedback',
    emoji: 'üí¨',
    githubLabel: 'feedback'
  },
  question: {
    label: 'Question',
    emoji: '‚ùì',
    githubLabel: 'question'
  }
};

// Keywords for automatic classification
const CLASSIFICATION_KEYWORDS: Record<string, string[]> = {
  bug: ['bug', 'error', 'crash', 'broken', 'not working', 'issue', 'problem', 'fail', 'falla', 'error', 'no funciona'],
  feature: ['feature', 'request', 'add', 'implement', 'suggestion', 'would be nice', 'funcionalidad', 'agregar', 'a√±adir'],
  question: ['how', 'what', 'why', 'when', 'where', 'can i', 'is it possible', 'c√≥mo', 'qu√©', 'por qu√©', 'puedo']
};

/**
 * Classify the ticket type based on message content
 */
function classifyTicket(text: string): string {
  const lowerText = text.toLowerCase();

  for (const [type, keywords] of Object.entries(CLASSIFICATION_KEYWORDS)) {
    if (keywords.some(keyword => lowerText.includes(keyword))) {
      return type;
    }
  }

  return 'feedback'; // Default classification
}

/**
 * Send a message via Telegram Bot API
 */
async function sendTelegramMessage(chatId: number, text: string): Promise<void> {
  const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;

  await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      chat_id: chatId,
      text: text,
      parse_mode: 'Markdown'
    })
  });
}

/**
 * Create a GitHub issue from the ticket
 */
async function createGitHubIssue(
  title: string,
  body: string,
  labels: string[]
): Promise<{ number: number; html_url: string } | null> {
  const url = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/issues`;

  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${GITHUB_TOKEN}`,
        'Content-Type': 'application/json',
        'Accept': 'application/vnd.github.v3+json',
        'User-Agent': 'OrionHealth-Support-Bot'
      },
      body: JSON.stringify({
        title,
        body,
        labels: [...labels, 'triage', 'from-telegram']
      })
    });

    if (!response.ok) {
      console.error('GitHub API error:', await response.text());
      return null;
    }

    return await response.json();
  } catch (error) {
    console.error('Error creating GitHub issue:', error);
    return null;
  }
}

/**
 * Generate the issue body with metadata
 */
function generateIssueBody(
  message: TelegramMessage,
  ticketType: TicketType,
  content: string
): string {
  const username = message.from.username
    ? `@${message.from.username}`
    : message.from.first_name;

  return `## ${ticketType.emoji} ${ticketType.label}

**Submitted via:** Telegram Bot
**From:** ${username}
**Date:** ${new Date(message.date * 1000).toISOString()}

---

### Description

${content}

---

<sub>ü§ñ Auto-generated by OrionHealth Support Bot</sub>
`;
}

/**
 * Handle the /start command
 */
function getWelcomeMessage(): string {
  return `üè• *Welcome to OrionHealth Support Bot!*

I can help you submit:
‚Ä¢ üêõ *Bug Reports* - Something not working?
‚Ä¢ ‚ú® *Feature Requests* - Have an idea?
‚Ä¢ üí¨ *Feedback* - Share your thoughts
‚Ä¢ ‚ùì *Questions* - Need help?

*How to submit:*
Just type your message and I'll automatically classify it and create a ticket for you.

*Commands:*
/bug - Report a bug
/feature - Request a feature
/feedback - Send feedback
/status - Check bot status

---
_Your privacy matters: Messages are only used to create GitHub issues._`;
}

/**
 * Handle the /status command
 */
function getStatusMessage(): string {
  return `‚úÖ *OrionHealth Support Bot Status*

üü¢ Bot: Online
üü¢ GitHub Integration: Connected
üìä Repository: ${GITHUB_OWNER}/${GITHUB_REPO}

_Report issues anytime - we're listening!_`;
}

/**
 * Main handler for incoming Telegram webhooks
 */
export default async function handler(request: Request): Promise<Response> {
  // Only accept POST requests
  if (request.method !== 'POST') {
    return new Response('Method not allowed', { status: 405 });
  }

  try {
    const update: TelegramUpdate = await request.json();
    const message = update.message;

    if (!message || !message.text) {
      return new Response('OK', { status: 200 });
    }

    const chatId = message.chat.id;
    const text = message.text.trim();

    // Handle commands
    if (text.startsWith('/')) {
      const command = text.split(' ')[0].toLowerCase();

      switch (command) {
        case '/start':
          await sendTelegramMessage(chatId, getWelcomeMessage());
          break;

        case '/status':
          await sendTelegramMessage(chatId, getStatusMessage());
          break;

        case '/bug':
        case '/feature':
        case '/feedback':
          const typeKey = command.slice(1);
          const content = text.slice(command.length).trim();

          if (!content) {
            await sendTelegramMessage(
              chatId,
              `Please provide a description after the command.\n\nExample: \`${command} Your description here\``
            );
          } else {
            await processTicket(message, typeKey, content);
          }
          break;

        default:
          await sendTelegramMessage(
            chatId,
            '‚ùì Unknown command. Send /start to see available commands.'
          );
      }
    } else {
      // Auto-classify and process the message
      const ticketType = classifyTicket(text);
      await processTicket(message, ticketType, text);
    }

    return new Response('OK', { status: 200 });

  } catch (error) {
    console.error('Webhook error:', error);
    return new Response('Internal Server Error', { status: 500 });
  }
}

/**
 * Process and create a ticket
 */
async function processTicket(
  message: TelegramMessage,
  ticketTypeKey: string,
  content: string
): Promise<void> {
  const chatId = message.chat.id;
  const ticketType = TICKET_TYPES[ticketTypeKey] || TICKET_TYPES.feedback;

  // Generate issue title (first 50 chars of content)
  const title = `[${ticketType.label}] ${content.slice(0, 50)}${content.length > 50 ? '...' : ''}`;

  // Generate issue body
  const body = generateIssueBody(message, ticketType, content);

  // Create GitHub issue
  const issue = await createGitHubIssue(title, body, [ticketType.githubLabel]);

  if (issue) {
    await sendTelegramMessage(
      chatId,
      `${ticketType.emoji} *Ticket Created!*

Your ${ticketType.label.toLowerCase()} has been submitted.

üé´ *Ticket #${issue.number}*
üîó [View on GitHub](${issue.html_url})

Thank you for helping improve OrionHealth! üíô`
    );
  } else {
    await sendTelegramMessage(
      chatId,
      `‚ùå *Error Creating Ticket*

Sorry, there was an issue creating your ticket. Please try again later or create an issue directly on [GitHub](https://github.com/${GITHUB_OWNER}/${GITHUB_REPO}/issues).`
    );
  }
}

// For Vercel Edge Functions
export const config = {
  runtime: 'edge',
};
